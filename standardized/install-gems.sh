#!/usr/bin/env bash

set -eEuo pipefail

trap 'printf "\n\e[31mError: Exit Status %s (%s)\e[m\n" $? "$(basename "$0")"' ERR

cd "$(dirname "$0")"

echo
echo "Start ($(basename "$0"))"

echo
echo "Install Gems"
echo "= = ="

if [ -z "${REMOVE_GEMS:-}" ]; then
  echo "REMOVE_GEMS is not set. Using \"on\" by default."
  remove_gems="on"
else
  remove_gems=$REMOVE_GEMS
fi

if [ -z "${POSTURE:-}" ]; then
  echo "POSTURE is not set. Using \"operational\" by default."
  POSTURE="operational"
fi

gem_dir="gems"
gem_exec_dir="$gem_dir/exec"
ruby_engine="$(ruby -e "puts RUBY_ENGINE")"
ruby_platform_version="$(ruby -rrbconfig -e "puts RbConfig::CONFIG['ruby_version']")"
install_dir="$gem_dir/$ruby_engine/$ruby_platform_version"
export GEM_HOME="$(realpath .)/$install_dir"

echo
echo "Posture: $POSTURE"
echo "Gem Home: $GEM_HOME"
echo "Gem Executables Dir: $gem_exec_dir"
echo "Remove Gems: $remove_gems"

echo
echo "Removing Gemfile.lock"
echo "- - -"

cmd="rm -rf Gemfile.lock"
echo $cmd
eval "$cmd"

if [ "$remove_gems" = "on" ]; then
  echo
  echo "Removing installed gems"
  echo "- - -"

  cmd="rm -rf $gem_dir"
  echo $cmd
  eval "$cmd"
fi

echo
echo "Installing gems"
echo "- - -"

cmd="gem install --no-user-install --bindir $gem_exec_dir --no-wrappers --file Gemfile --lock"
if [ "$POSTURE" != "operational" ]; then
  cmd="$cmd --development"
fi
echo $cmd
eval "$cmd"

if grep -q gemspec Gemfile; then
  project_gems=($(
    find . -maxdepth 2 -type f -name '*gemspec' |
      ruby -rrubygems -n -e 'spec = Gem::Specification.load($_.chomp); puts spec.name')
  )
  cmd="gem uninstall --executables --no-user-install ${project_gems[@]}"
  echo -e "\n$cmd"
  eval "$cmd"
else
  project_gems=()
fi
project_gems_rb_array="$(ruby -n -e 'puts $_.chomp.split.inspect' <<<"${project_gems[@]}")"

echo
echo "Generating gems/gems_init.rb"
echo "- - -"

mkdir -p gems

ruby -rrubygems -rpathname <<RUBY
gem_dir = Pathname('$gem_dir')
gem_path = Pathname('$GEM_HOME')

gem_path_relative = gem_path.relative_path_from(File.join(Dir.pwd, 'gems'))

gem_dir.join('gems_init.rb').open('w') do |gems_init_rb|

  gems_init_rb.puts <<~RUBY
  # Generated by $0

  if not RUBY_VERSION == '#{RUBY_VERSION}'
    warn "Gems were installed with Ruby #{RUBY_VERSION}, but \#{RUBY_VERSION} is active"
  end

  gem_path = File.expand_path('#{gem_path_relative}', __dir__)

  if Object.const_defined?(:Gem)
    Gem.path.unshift(gem_path)
    Gem.refresh
    return

  elsif ENV['AUTOLOAD_RUBYGEMS'] == 'on'
    ENV['GEM_PATH'] = "\#{gem_path}:\#{ENV['GEM_PATH']}"

    Kernel.autoload(:Gem, 'rubygems')

    module Kernel
      def gem(...)
        require 'rubygems'
        Kernel.gem(...)
      end
    end
  end
  RUBY

  gem_require_paths = []

  gem_request_set = ::Gem::RequestSet.new
  gem_request_set.load_gemdeps('Gemfile')
  gem_request_set.resolve_current
  gem_request_set.sorted_requests.each do |activation_request|
    spec = activation_request.spec.spec

    if $project_gems_rb_array.include?(spec.name)
      next
    end

    spec.full_require_paths.each do |full_require_path|
      full_require_path = Pathname(full_require_path)

      require_path = full_require_path.relative_path_from(gem_path.expand_path)

      gem_require_paths << require_path.to_s

      puts "Load path: #{full_require_path.relative_path_from(Dir.pwd)}"
    end
  end

  gems_init_rb.puts <<~RUBY

  [
    #{gem_require_paths.map(&:dump).join(",\n  ")}
  ].each do |gem_require_path|
    full_gem_require_path = File.expand_path(gem_require_path, gem_path)
    \$LOAD_PATH.push(full_gem_require_path) if not \$LOAD_PATH.include?(full_gem_require_path)
  end
  RUBY

  default_dir = Gem.default_path.reverse.find { it != Gem.vendor_dir }
  if not default_dir == Gem.default_dir
    non_default_system_gem_require_paths = []

    Gem::Specification.each_spec([File.join(default_dir, 'specifications')]) do |spec|
      spec.full_require_paths.each do |full_require_path|
        full_require_path = Pathname(full_require_path)

        require_path = full_require_path.relative_path_from(default_dir)

        non_default_system_gem_require_paths << require_path.to_s
      end
    end

    gems_init_rb.puts <<~RUBY

    [
      #{non_default_system_gem_require_paths.map(&:dump).join(",\n  ")}
    ].each do |gem_require_path|
      full_gem_require_path = File.expand_path(gem_require_path, '#{default_dir}')
      \$LOAD_PATH.push(full_gem_require_path) if not \$LOAD_PATH.include?(full_gem_require_path)
    end
    RUBY
  end

  puts "Wrote #{gems_init_rb.path}"
end
RUBY

echo
echo "Generating Executables"
echo "- - -"
ruby -rrubygems -rpathname <<RUBY
gem_home = Pathname('$GEM_HOME')

gem_exec_dir = Pathname('$gem_exec_dir')
if not gem_exec_dir.directory?
  gem_exec_dir.mkdir
end

gem_request_set = ::Gem::RequestSet.new
gem_request_set.load_gemdeps('Gemfile')
gem_request_set.resolve_current
gem_request_set.sorted_requests.each do |activation_request|
  spec = activation_request.spec.spec

  if $project_gems_rb_array.include?(spec.name)
    next
  end

  spec.executables.each do |executable|
    gem_executable_path = Pathname(spec.full_gem_path).join(spec.bindir, executable)

    relative_executable_path = gem_executable_path.relative_path_from(gem_exec_dir.expand_path)

    executable_path = gem_exec_dir.join(executable)

    if executable_path.symlink?
      executable_path.unlink
      puts "Found symbolic link at #{executable_path}; it will be replaced by this script"
    else
      warn "Expected symbolic link at #{executable_path}"
    end

    executable_path.open('w', 0755) do |exec|
      exec.write(<<~RUBY)
#!/usr/bin/env ruby
require_relative '../gems_init.rb'
load File.expand_path('#{relative_executable_path}', __dir__)
      RUBY
    end

    puts "Wrote #{executable_path}"
  end
end
RUBY

echo
echo "Done ($(basename "$0"))"
